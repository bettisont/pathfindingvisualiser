{"version":3,"sources":["PathfindingVisualiser/Node/Node.jsx","algorithms/dijkstra.js","algorithms/a*.js","PathfindingVisualiser/Pathfindingvisualiser.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","col","isFinish","isStart","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","getNotVisitedNodes","grid","nodesToReturn","x","length","y","element","push","sortNodes","nodes","sort","a","b","distance","getNeighbours","currentNode","neighbours","filter","neighbour","updateNeighbours","forEach","previousNode","sortByHeuristic","openList","heuristic","PathfindingVisualiser","handleMouseDown","newGrid","slice","setState","mouseIsPressed","handleMouseEnter","getInitialGrid","onClick","visualiseDijkstra","generateRandomWalls","recursiveDivisionMazeGeneration","visualiseAstar","map","rowIdx","node","nodeIdx","handleMouseUp","console","log","thisRow","thisNode","Math","random","visitedNodesInOrder","i","setTimeout","document","getElementById","nodesInShortestPath","startNode","finishNode","endNode","visitedNodes","Infinity","dijkstra","unshift","getNodesInShortestPathOrder","animateDijkstra","animateShortestPath","closedList","shift","index","abs","aStar","animateAstar","currentRow","createNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"6SAGqBA,G,wDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,qDAKT,IAAD,EAWHC,KAAKF,MATPG,EAFK,EAELA,IACAC,EAHK,EAGLA,SACAC,EAJK,EAILA,QAEAC,GANK,EAKLC,UALK,EAMLD,QACAE,EAPK,EAOLA,YACAC,EARK,EAQLA,aACAC,EATK,EASLA,UACAC,EAVK,EAULA,IAGIC,EAAiBR,EACnB,cACAC,EACA,aACAC,EACA,YACA,GACJ,OACE,qBACEO,GAAE,eAAUF,EAAV,YAAiBR,GACnBW,UAAS,eAAUF,GACnBJ,YAAa,kBAAMA,EAAYG,EAAKR,IACpCM,aAAc,kBAAMA,EAAaE,EAAKR,IACtCO,UAAW,kBAAMA,W,GAhCSK,c,MCgClC,IAAMC,EAAqB,SAACC,GAE1B,IADA,IAAMC,EAAgB,GACbC,EAAI,EAAGA,EAAIF,EAAKG,OAAQD,IAE/B,IADA,IAAMR,EAAMM,EAAKE,GACRE,EAAI,EAAGA,EAAIV,EAAIS,OAAQC,IAAK,CACnC,IAAMC,EAAUX,EAAIU,GACfC,EAAQf,WAAce,EAAQhB,QACjCY,EAAcK,KAAKD,GAIzB,OAAOJ,GAGHM,EAAY,SAACC,GAIjB,OAHAA,EAAMC,MAAK,SAAUC,EAAGC,GACtB,OAAOD,EAAEE,SAAWD,EAAEC,YAEjBJ,GAGT,SAASK,EAAcb,EAAMc,GAC3B,IAAMC,EAAa,GACXrB,EAAaoB,EAAbpB,IAAKR,EAAQ4B,EAAR5B,IAKb,OAJIQ,EAAM,GAAGqB,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,IACvCQ,EAAMM,EAAKG,OAAS,GAAGY,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,IACrDA,EAAM,GAAG6B,EAAWT,KAAKN,EAAKN,GAAKR,EAAM,IACzCA,EAAMc,EAAK,GAAGG,OAAS,GAAGY,EAAWT,KAAKN,EAAKN,GAAKR,EAAM,IACvD6B,EAAWC,QAAO,SAACC,GAAD,OAAgBA,EAAU3B,aAGrD,SAAS4B,EAAiBH,EAAYD,GACpCC,EAAWI,SAAQ,SAACd,GAClBA,EAAQO,SAAWE,EAAYF,SAAW,EAC1CP,EAAQe,aAAeN,KCK3B,IAAMO,EAAkB,SAACC,GAIvB,OAHAA,EAASb,MAAK,SAAUC,EAAGC,GACzB,OAAOD,EAAEa,UAAYZ,EAAEY,aAElBD,GAGT,SAAST,EAAcb,EAAMc,GAC3B,IAAMC,EAAa,GACXrB,EAAaoB,EAAbpB,IAAKR,EAAQ4B,EAAR5B,IAab,OAZIQ,EAAM,GAAGqB,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,IACvCQ,EAAMM,EAAKG,OAAS,GAAGY,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,IACrDA,EAAM,GAAG6B,EAAWT,KAAKN,EAAKN,GAAKR,EAAM,IACzCA,EAAMc,EAAK,GAAGG,OAAS,GAAGY,EAAWT,KAAKN,EAAKN,GAAKR,EAAM,IAE1DQ,EAAM,GAAKR,EAAM,GAAG6B,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,EAAM,IACxDA,EAAM,GAAKQ,EAAMM,EAAKG,OAAS,GAAGY,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,EAAM,IACtEA,EAAMc,EAAK,GAAGG,OAAS,GAAKT,EAAMM,EAAKG,OAAS,GAClDY,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,EAAM,IAClCA,EAAMc,EAAK,GAAGG,OAAS,GAAKT,EAAM,GACpCqB,EAAWT,KAAKN,EAAKN,EAAM,GAAGR,EAAM,IAE/B6B,EAAWC,QAAO,SAACC,GAAD,OAAgBA,EAAU5B,UCtFrD,IAQqBmC,E,kDACnB,WAAYzC,GAAQ,IAAD,8BACjB,cAAMA,IAYR0C,gBAAkB,SAAC/B,EAAKR,GACtB,IAAMwC,EAAU,EAAK1C,MAAMgB,KAAK2B,QAChCD,EAAQhC,GAAKR,GAAKG,QAAUqC,EAAQhC,GAAKR,GAAKG,OAC9C,EAAKuC,SAAS,CAAE5B,KAAM0B,IACtB,EAAKE,SAAS,CAAEC,gBAAgB,KAjBf,EAoBnBC,iBAAmB,SAACpC,EAAKR,GACvB,GAAI,EAAKF,MAAM6C,eAAgB,CAC7B,IAAMH,EAAU,EAAK1C,MAAMgB,KAAK2B,QAChCD,EAAQhC,GAAKR,GAAKG,QAAS,EAC3B,EAAKuC,SAAS,CAAE5B,KAAM0B,MAtBxB,EAAK1C,MAAQ,CACXgB,KAAM,GACN6B,gBAAgB,GAJD,E,gEASjB,IAAM7B,EAAO+B,IACb9C,KAAK2C,SAAS,CAAE5B,W,sCAmBhBf,KAAK2C,SAAS,CAAEC,gBAAgB,M,+BAExB,IAAD,SAC0B5C,KAAKD,MAA9BgB,EADD,EACCA,KAAM6B,EADP,EACOA,eACd,OACE,qCACE,wBAAQG,QAAS,kBAAM,EAAKC,qBAA5B,4CAGA,wBAAQD,QAAS,kBAAM,EAAKE,uBAA5B,mCAGA,wBAAQF,QAAS,kBAAM,EAAKG,mCAA5B,iDAGA,wBAAQH,QAAS,kBAAM,EAAKI,kBAA5B,oCAGA,qBAAKvC,UAAU,OAAf,SACGG,EAAKqC,KAAI,SAAC3C,EAAK4C,GACd,OACE,8BACG5C,EAAI2C,KAAI,SAACE,EAAMC,GAAa,IAEzBpD,EAMEmD,EANFnD,QACAD,EAKEoD,EALFpD,SAEAO,GAGE6C,EAJFjD,UAIEiD,EAHF7C,KACAR,EAEEqD,EAFFrD,IACAG,EACEkD,EADFlD,OAEF,OACE,cAAC,EAAD,CAEEH,IAAKA,EACLC,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRwC,eAAgBA,EAChBtC,YAAa,SAACG,EAAKR,GAAN,OAAc,EAAKuC,gBAAgB/B,EAAKR,IACrDM,aAAc,SAACE,EAAKR,GAAN,OACZ,EAAK4C,iBAAiBpC,EAAKR,IAE7BO,UAAW,kBAAM,EAAKgD,iBACtB/C,IAAKA,GAXA8C,OAZHF,a,4CAoCpBI,QAAQC,IAAI,8BAEZ,IADA,IAAMjB,EAAUzC,KAAKD,MAAMgB,KAAK2B,QACvBjC,EAAM,EAAGA,EAAMgC,EAAQvB,OAAQT,IAEtC,IADA,IAAMkD,EAAUlB,EAAQhC,GACfR,EAAM,EAAGA,EAAM0D,EAAQzC,OAAQjB,IAAO,CAC7C,IAAM2D,EAAWnB,EAAQhC,GAAKR,GAC1B4D,KAAKC,SAAW,KAAQF,EAASzD,UAAYyD,EAAS1D,WACxD0D,EAASxD,QAAS,GAGxBJ,KAAK2C,SAAS,CAAE5B,KAAM0B,M,sDAGQ1B,GACdf,KAAKD,MAAMgB,KAAK2B,QACVmB,KAAKC,W,8EAKbC,GACd,IADoC,IAAD,WAC1BC,GACPC,YAAW,WACT,IAAMX,EAAOS,EAAoBC,GACjCE,SAASC,eAAT,eAAgCb,EAAK7C,IAArC,YAA4C6C,EAAKrD,MAAOW,UACtD,sBAlHW,GAmHGoD,IALXA,EAAI,EAAGA,EAAID,EAAoB7C,OAAQ8C,IAAM,EAA7CA,K,0CASSI,GAClB,IADwC,IAAD,WAC9BJ,GACPC,YAAW,WACT,IAAMX,EAAOc,EAAoBJ,GACjCE,SAASC,eAAT,eAAgCb,EAAK7C,IAArC,YAA4C6C,EAAKrD,MAAOW,UACtD,4BACD,GAAKoD,IALDA,EAAI,EAAGA,EAAII,EAAoBlD,OAAQ8C,IAAM,EAA7CA,K,0CASU,IAAD,OACVjD,EAASf,KAAKD,MAAdgB,KACFsD,EAAYtD,EAzIC,IACA,GAyIbuD,EAAavD,EAxIC,IACA,IAwIdgD,EFrJH,SAAkBhD,EAAMsD,EAAWE,GACxCF,EAAU1C,SAAW,EAMrB,IAHA,IAAMJ,EAAQT,EAAmBC,GAE3ByD,EAAe,GACdjD,EAAML,OAAS,GAAG,CACvB,IAAMK,EAAQT,EAAmBC,GAG3Bc,EAFcP,EAAUC,GAEE,GAEhC,GAAIM,EAAYF,WAAa8C,IAC3B,OAAOD,EAGT,GAAI3C,IAAgB0C,EAGlB,OAFAA,EAAQlE,WAAY,EACpBmE,EAAanD,KAAKQ,GACX2C,EAGT3C,EAAYxB,WAAY,EAExBmE,EAAanD,KAAKQ,GAIlBI,EAFmBL,EAAcb,EAAMc,GAEVA,IEwHD6C,CAAS3D,EAAMsD,EAAWC,GAChDF,EF7EH,SAAqCE,GAC1C,IAAMF,EAAsB,GACxBvC,EAAcyC,EAElB,IADAb,QAAQC,IAAIY,GACW,OAAhBzC,GACLuC,EAAoBO,QAAQ9C,GAC5BA,EAAcA,EAAYM,aAE5B,OAAOiC,EEqEuBQ,CAA4BN,GACxDtE,KAAK6E,gBAAgBd,GACrBE,YAAW,WACT,EAAKa,oBAAoBV,KAzIV,GA0IdL,EAAoB7C,OAAwB,K,mCAGpC6C,GACX,IADiC,IAAD,WACvBC,GACPC,YAAW,WACT,IAAMX,EAAOS,EAAoBC,GACjCE,SAASC,eAAT,eAAgCb,EAAK7C,IAArC,YAA4C6C,EAAKrD,MAAOW,UACtD,sBAlJW,GAmJGoD,IALXA,EAAI,EAAGA,EAAID,EAAoB7C,OAAQ8C,IAAM,EAA7CA,K,uCASO,IACRjD,EAASf,KAAKD,MAAdgB,KAIFgD,ED5KH,SAAehD,EAAMsD,EAAWC,GAErC,IAAIjC,EAAW,GACX0C,EAAa,GAMjB,IALAV,EAAU1C,SAAW,EAErBU,EAAShB,KAAKgD,GAGPhC,EAASnB,OAAS,GAAG,CAE1BuC,QAAQC,IAAIrB,GACZ,IACMR,EADiBO,EAAgBC,GACJ,GACnCoB,QAAQC,IAAI7B,GACZQ,EAAS2C,QAKT,IAFA,IAAMlD,EAAaF,EAAcb,EAAMc,GATb,WAWjBoD,GACP,IAAMjD,EAAYF,EAAWmD,GAE7B,GAAIjD,IAAcsC,EAEhB,OADAS,EAAW1D,KAAKQ,EAAayC,GACvB,CAAN,EAAOS,GAGT/C,EAAUG,aAAeN,EAEzBG,EAAUL,SAAWE,EAAYF,SAAW,EAE5CK,EAAUM,UACRuB,KAAKqB,IAAIlD,EAAU/B,IAAMqE,EAAWrE,KACpC4D,KAAKqB,IAAIlD,EAAUvB,IAAM6D,EAAWrE,KACtC,IAAIwB,GAAI,EACJC,GAAI,EAoBR,OAnBAW,EAASH,SAAQ,SAACd,GAEdA,EAAQX,MAAQuB,EAAUvB,KAC1BW,EAAQnB,MAAQmB,EAAQnB,KACxBmB,EAAQkB,UAAYN,EAAUM,YAE9Bb,GAAI,MAGRsD,EAAW7C,SAAQ,SAACd,GAEhBA,EAAQX,MAAQuB,EAAUvB,KAC1BW,EAAQnB,MAAQmB,EAAQnB,KACxBmB,EAAQkB,UAAYN,EAAUM,YAE9BZ,GAAI,MAIJD,GAIKC,EAHP,gBAQAW,EAAShB,KAAKW,IA7CTiD,EAAQ,EAAGA,EAAQnD,EAAWZ,OAAQ+D,IAAS,CAAC,IAAD,IAA/CA,GAA+C,kDAkDxDF,EAAW1D,KAAKQ,ICsGYsD,CAAMpE,EAHhBA,EA/JC,IACA,GA+JAA,EA9JC,IACA,KAgKpBf,KAAKoF,aAAarB,GAClBN,QAAQC,IAAIK,O,GA5JmClD,aAgK7CiC,EAAiB,WAErB,IADA,IAAM/B,EAAO,GACJN,EAAM,EAAGA,EAtKF,GAsKmBA,IAAO,CAExC,IADA,IAAM4E,EAAa,GACVpF,EAAM,EAAGA,EAvKJ,GAuKqBA,IACjCoF,EAAWhE,KAAKiE,EAAWrF,EAAKQ,IAElCM,EAAKM,KAAKgE,GAEZ,OAAOtE,GAGHuE,EAAa,SAACrF,EAAKQ,GACvB,MAAO,CACLR,MACAQ,MACAN,QAxLmB,KAwLVM,GAvLU,IAuLgBR,EACnCC,SAvLoB,KAuLVO,GAtLU,KAsLiBR,EACrC0B,SAAU8C,IACVpE,WAAW,EACXD,QAAQ,EACR+B,aAAc,KAEdG,UAAW,OC9LAiD,MARf,WACE,OACE,qBAAK3E,UAAU,MAAf,SACE,cAAC,EAAD,OCMS4E,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFjC,SAASC,eAAe,SAM1BqB,M","file":"static/js/main.ff39ddb5.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isVisited,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","export function dijkstra(grid, startNode, endNode) {\n  startNode.distance = 0;\n\n  // array of distances from source node s to all nodes in the graph\n  const nodes = getNotVisitedNodes(grid);\n\n  const visitedNodes = [];\n  while (nodes.length > 0) {\n    const nodes = getNotVisitedNodes(grid);\n    const sortedNodes = sortNodes(nodes);\n\n    const currentNode = sortedNodes[0];\n\n    if (currentNode.distance === Infinity) {\n      return visitedNodes;\n    }\n\n    if (currentNode === endNode) {\n      endNode.isVisited = true;\n      visitedNodes.push(currentNode);\n      return visitedNodes;\n    }\n\n    currentNode.isVisited = true;\n\n    visitedNodes.push(currentNode);\n\n    const neighbours = getNeighbours(grid, currentNode);\n\n    updateNeighbours(neighbours, currentNode);\n  }\n}\n\n// RETURN array of visited nodes in the order that we visited them (when we reach the finish node)\n\nconst getNotVisitedNodes = (grid) => {\n  const nodesToReturn = [];\n  for (let x = 0; x < grid.length; x++) {\n    const row = grid[x];\n    for (let y = 0; y < row.length; y++) {\n      const element = row[y];\n      if (!element.isVisited && !element.isWall) {\n        nodesToReturn.push(element);\n      }\n    }\n  }\n  return nodesToReturn;\n};\n\nconst sortNodes = (nodes) => {\n  nodes.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return nodes;\n};\n\nfunction getNeighbours(grid, currentNode) {\n  const neighbours = [];\n  const { row, col } = currentNode;\n  if (row > 0) neighbours.push(grid[row - 1][col]); //top\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]); //below\n  if (col > 0) neighbours.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\n}\n\nfunction updateNeighbours(neighbours, currentNode) {\n  neighbours.forEach((element) => {\n    element.distance = currentNode.distance + 1;\n    element.previousNode = currentNode;\n  });\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPath = [];\n  let currentNode = finishNode;\n  console.log(finishNode);\n  while (currentNode !== null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPath;\n}\n","export function aStar(grid, startNode, finishNode) {\n  //let nodes = getNotVisitedNodes(grid);\n  let openList = [];\n  let closedList = [];\n  startNode.distance = 0;\n  // put starting node in openList\n  openList.push(startNode);\n  // while openList is not empty\n\n  while (openList.length > 0) {\n    // get node with the least f (distance + euclidian distance) in the openList\n    console.log(openList);\n    const sortedOpenList = sortByHeuristic(openList);\n    const currentNode = sortedOpenList[0];\n    console.log(currentNode);\n    openList.shift();\n    // console.log(currentNode);\n    // FOREACH neighbour of currentnNode //\n    const neighbours = getNeighbours(grid, currentNode);\n\n    for (let index = 0; index < neighbours.length; index++) {\n      const neighbour = neighbours[index];\n      // IF neighbour is goal: Stop search\n      if (neighbour === finishNode) {\n        closedList.push(currentNode, finishNode);\n        return closedList;\n      }\n      // update neighbour.previousNode to be the currentNode\n      neighbour.previousNode = currentNode;\n      // neighbour.distance = currentNode.distance + 1\n      neighbour.distance = currentNode.distance + 1;\n      // neighbour.heuristic = neigbour.distance + neighbour.euclidianDistanceToGoal\n      neighbour.heuristic =\n        Math.abs(neighbour.col - finishNode.col) +\n        Math.abs(neighbour.row - finishNode.col);\n      let a = false;\n      let b = false;\n      openList.forEach((element) => {\n        if (\n          element.row === neighbour.row &&\n          element.col === element.col &&\n          element.heuristic < neighbour.heuristic\n        ) {\n          a = true;\n        }\n      });\n      closedList.forEach((element) => {\n        if (\n          element.row === neighbour.row &&\n          element.col === element.col &&\n          element.heuristic < neighbour.heuristic\n        ) {\n          b = true;\n        }\n      });\n      // IF neighbour is already in openList with a LOWER heuristic: SKIP this neighbour\n      if (a) {\n        continue;\n      }\n      // ELIF neighbour is in closedList with a LOWER heuristic: SKIP this neighbour\n      else if (b) {\n        continue;\n      }\n      // ELSE add this neighbour to the openList\n      else {\n        openList.push(neighbour);\n      }\n      // END FOREACH\n    }\n    // add currentNode to the closedList\n    closedList.push(currentNode);\n  }\n}\n\nconst sortByHeuristic = (openList) => {\n  openList.sort(function (a, b) {\n    return a.heuristic - b.heuristic;\n  });\n  return openList;\n};\n\nfunction getNeighbours(grid, currentNode) {\n  const neighbours = [];\n  const { row, col } = currentNode;\n  if (row > 0) neighbours.push(grid[row - 1][col]); //top\n  if (row < grid.length - 1) neighbours.push(grid[row + 1][col]); //below\n  if (col > 0) neighbours.push(grid[row][col - 1]); //left\n  if (col < grid[0].length - 1) neighbours.push(grid[row][col + 1]); // right\n\n  if (row > 0 && col > 0) neighbours.push(grid[row - 1][col - 1]); // top left\n  if (col > 0 && row < grid.length - 1) neighbours.push(grid[row + 1][col - 1]); // bottom left\n  if (col < grid[0].length - 1 && row < grid.length - 1)\n    neighbours.push(grid[row + 1][col + 1]); // bottom right\n  if (col < grid[0].length - 1 && row > 0)\n    neighbours.push(grid[row - 1][col + 1]); // top right\n\n  return neighbours.filter((neighbour) => !neighbour.isWall);\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport \"./Pathfindingvisualiser.css\";\nimport {\n  dijkstra,\n  getNodesInShortestPathOrder,\n} from \"../algorithms/dijkstra.js\";\n\nimport { aStar } from \"../algorithms/a*.js\";\n\nconst START_NODE_ROW = 14;\nconst START_NODE_COL = 5;\nconst FINISH_NODE_ROW = 14;\nconst FINISH_NODE_COL = 20;\nconst ROW_COUNT = 25;\nconst COL_COUNT = 25;\nconst REFRESH_RATE = 15;\n\nexport default class PathfindingVisualiser extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({ grid });\n  }\n\n  handleMouseDown = (row, col) => {\n    const newGrid = this.state.grid.slice();\n    newGrid[row][col].isWall = !newGrid[row][col].isWall;\n    this.setState({ grid: newGrid });\n    this.setState({ mouseIsPressed: true });\n  };\n\n  handleMouseEnter = (row, col) => {\n    if (this.state.mouseIsPressed) {\n      const newGrid = this.state.grid.slice();\n      newGrid[row][col].isWall = true;\n      this.setState({ grid: newGrid });\n    }\n  };\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n    return (\n      <>\n        <button onClick={() => this.visualiseDijkstra()}>\n          Visualise Dijkstra's Algorithm\n        </button>\n        <button onClick={() => this.generateRandomWalls()}>\n          Generate Random Walls\n        </button>\n        <button onClick={() => this.recursiveDivisionMazeGeneration()}>\n          Maze Generation: Recursive Division\n        </button>\n        <button onClick={() => this.visualiseAstar()}>\n          Visualise A* Algorithm\n        </button>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    isStart,\n                    isFinish,\n                    isVisited,\n                    row,\n                    col,\n                    isWall,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n\n  generateRandomWalls() {\n    console.log(\"random wall method called!\");\n    const newGrid = this.state.grid.slice();\n    for (let row = 0; row < newGrid.length; row++) {\n      const thisRow = newGrid[row];\n      for (let col = 0; col < thisRow.length; col++) {\n        const thisNode = newGrid[row][col];\n        if (Math.random() > 0.8 && !thisNode.isStart && !thisNode.isFinish)\n          thisNode.isWall = true;\n      }\n    }\n    this.setState({ grid: newGrid });\n  }\n\n  recursiveDivisionMazeGeneration(grid) {\n    const newGrid = this.state.grid.slice();\n    const verticalSplit = Math.random() > 0.5 ? true : false;\n  }\n\n  mazeDivision() {}\n\n  animateDijkstra(visitedNodesInOrder) {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, REFRESH_RATE * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPath) {\n    for (let i = 0; i < nodesInShortestPath.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPath[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 30 * i);\n    }\n  }\n\n  visualiseDijkstra() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPath = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder);\n    setTimeout(() => {\n      this.animateShortestPath(nodesInShortestPath);\n    }, visitedNodesInOrder.length * REFRESH_RATE + 2);\n  }\n\n  animateAstar(visitedNodesInOrder) {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, REFRESH_RATE * i);\n    }\n  }\n\n  visualiseAstar() {\n    const { grid } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n    const visitedNodesInOrder = aStar(grid, startNode, finishNode);\n    this.animateAstar(visitedNodesInOrder);\n    console.log(visitedNodesInOrder);\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < ROW_COUNT; row++) {\n    const currentRow = [];\n    for (let col = 0; col < COL_COUNT; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n\n    heuristic: null,\n  };\n};\n","import \"./App.css\";\nimport Pathfindingvisualiser from \"./PathfindingVisualiser/Pathfindingvisualiser\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfindingvisualiser></Pathfindingvisualiser>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}